initialize() {
	
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy",periodicity="xy");
	initializeTreeSeq();
	
	// will be used from computing harmonic mean of pop size
	//	defineGlobal("h_harm", c());
	//	defineGlobal("p_harm", c());	
	
	defaults = Dictionary(
		"Lh", 500000,
		"Lp", 500000,
		"hSD", 2.0,  			// host dispersal distance	
		"SI", 1.0,  			// spatial interspp interaction distance
		"W", 100.0,  			// width and height of the simulated area
		"ch", 0.2, 			// strength of host competition
		"lmbda", 2.0,		// (spatial) niche breadth
		"h_base", 2.0,		// host base fitness
		"hc", 0.99 		// multiplicative cost on host fitness for each infection
		);		
	catn("-------------\n");
	for (k in defaults.allKeys) {
		if (!exists(k)) {
			defineConstant(k, defaults.getValue(k));
		} else {
			defaults.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
		catn("  " + k + ": " + defaults.getValue(k));
	}
	catn("-------------\n");
	defineGlobal("params", defaults);
	defineConstant("hSM", hSD);  			// host mate choice distance
	
	
	// we make two sets of loci, one for each species
	// the first set of loci will be ignored by spp 2
	// the second set of loci will be ignored by spp 1
	
	// causal loci are biallelic with two alleles denoted 0,1
	CausalScrpt = "if (runif(1) < 0.5) 0; else 1;";
	// need to rewrite so that if current state is X, replace with 1-X
	initializeMutationType("m1", 0.5, "s", CausalScrpt);
	initializeMutationType("m2", 0.5, "s", CausalScrpt);
	
	// m1 for host and m2 for parasite
	m1.convertToSubstitution = F;  	// do these need to be kept?
	m1.mutationStackPolicy = "l";  	// instead of stacking, use last mutation
	m1.color = "yellow";	
	m2.convertToSubstitution = F;  	// do these need to be kept?
	m2.mutationStackPolicy = "l";	// instead of stacking, use last mutation
	m2.color = "pink";
	
	// host chromosome	
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 2*Lh);
	
	// para chromosome
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g2, 2*Lh+1, 2*Lh+2*Lp+1);
	
	// mutation rate of 1e-8 at causal loci
	initializeMutationRate(c(0,1e-8,0,1e-8,0),c(Lh-1,Lh,2*Lh+Lp,2*Lh+Lp+1,2*Lh+2*Lp+1));
	
	// make host and para loci physically unlinked
	initializeRecombinationRate(1e-7);
	
	// can use same interaction type for each species as long as they have same parameters (such as distance of spatial comp)	
	
	// host spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=lmbda);

	// host mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=hSM);

}

// make causal mutions "neutral" :B
fitness(m1) { return 1.0; }
fitness(m2) { return 1.0; }

// host mating
reproduction(p1) {
	mate = i2.drawByStrength(individual, 1); // find a single partner to mate with
	if(mate.size()) {
		nOff = rpois(1, individual.tagF);
		for(i in seqLen(nOff)) {
			pos = 0.5*(individual.spatialPosition + mate.spatialPosition) + rnorm(2, 0, hSD); // add dispersal
			bb = subpop.addCrossed(individual, mate);
			bb.setSpatialPosition(p1.pointPeriodic(pos));
		}
	}
	return;
}

1 early() {
	
	// distribute a bunch of individuals uniformly in space
	IPS = asInteger(1 * W * W); // Initial Population Size
	sim.addSubpop("p1", IPS);
	p1.setSpatialBounds(c(0, 0, W, W));
	p1.individuals.setSpatialPosition(p1.pointUniform(IPS));

	// initiates standing variation at causal loci
	//	sim.readFromPopulationFile(msprime_file);
	g = sim.subpopulations.genomes;
	isPlus = asLogical(rbinom(size(g), 1, 0.5));
	g[isPlus].addNewMutation(m1, 1.0, Lh);
	g[!isPlus].addNewMutation(m1, 0.0, Lh);
	isPlus = asLogical(rbinom(size(g), 1, 0.5));
	g[isPlus].addNewMutation(m2, 1.0, 2*Lh+Lp+1);
	g[!isPlus].addNewMutation(m2, 0.0, 2*Lh+Lp+1);
	
}

late() {

	i1.evaluate(p1);
	i2.evaluate(p1);
		
	// caculating the phenotype as sum of loci with mutation
	h_trt = p1.individuals.sumOfMutationsOfType(m1);
	
	// save trait values
	p1.individuals.z = h_trt;
	
	// identify genotypes by brightness
	for(ind in p1.individuals){
		val = 0.25+0.75*ind.z/2;
		ind.color = rgb2color(hsv2rgb(c(1.0, 0.0, val)));
	}
	
	// compute fx of intraspp compet on host fecun
	for(h in p1.individuals){
		h_loc = c(h.x,h.y);
		h_nbrs = i1.nearestNeighborsOfPoint(p1, h_loc, count=p1.individualCount); // might not know about periodicity
		h_nbs = length(h_nbrs);
		h.tagF = h_base*exp(-ch*h_nbs);
	}	
		
	// forces non-overlapping generations
	p1.individuals.fitnessScaling = 0;
	
}

1000 late() {
	sim.treeSeqOutput("slim.trees", metadata=params);
	catn("Done.");
   sim.simulationFinished();
}
