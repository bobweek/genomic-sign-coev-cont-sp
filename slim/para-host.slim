// get avg muts per ind

species all initialize(){
	initializeSLiMModelType("nonWF");
	// model parameters
	defaults = Dictionary(	
		"Âµâ‚•",  1e-11,  		// host mutation rate
		"Âµâ‚š",  1e-11,  		// parasite mutation rate
		"Îºâ‚•",  0.01,  	// host mutation effect size
		"Îºâ‚š",  0.01,  	// parasite mutation effect size		
		"Ïƒâ‚•",  2.0,  		// host dispersal distance
		"Ïƒâ‚š",  0.5,  		// parasite dispersal distance
		"Î¹",   3.0,			// spatial interspp interaction distance
		"câ‚•",  0.05, 		// strength of host competition
		"câ‚š",  0.02, 		// strength of para competition
		"Ï‰â‚•",  3.0,			// (spatial) host niche breadth 
		"Ï‰â‚š",  3.0,			// (spatial) parasite niche breadth
		"Wâ‚€â‚•", 1.03,		// host base fitness
		"Wâ‚€â‚š", 1.02,		// para base fitness
		"sâ‚•",  0.001, 		// cost on host fitness for each infection ('s' as in selection)
		"sâ‚š",  0.01, 		// benefit on parasite fitness for successful infection
		"Î³",   0.5,			// sensitivity of inf pr to trait differences ('gamma' trad nuimser notation for this par)
		"Ïâ‚€",  0.5,			// initial population density ('rho' is trad for densities)
		"ntlbrnn", 9999,	// number of cycles in neutral burnin period
		"ixnbrnn", 20000	// number of cycles in interacting burnin period
		);
	for (k in defaults.allKeys) {
		if (!exists(k)) {
			defineConstant(k, defaults.getValue(k));
		} else {
			defaults.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
	}
	defineGlobal("params", defaults);
	catn(params);
	
	// temporal resolution of time-series
	defineConstant("tempres", 100);
	
	// params.csv
	pfn = "~/gsccs-data/params.csv";
	writeFile(pfn,paste("Âµâ‚•","Âµâ‚š","Îºâ‚•","Îºâ‚š","Ïƒâ‚•","Ïƒâ‚š","Î¹","câ‚•","câ‚š","Ï‰â‚•","Ï‰â‚š",
		"Wâ‚€â‚•","Wâ‚€â‚š","sâ‚•","sâ‚š","Î³","Ïâ‚€","tempres",sep=","),append=F);
	writeFile(pfn,paste(Âµâ‚•,Âµâ‚š,Îºâ‚•,Îºâ‚š,Ïƒâ‚•,Ïƒâ‚š,Î¹,câ‚•,câ‚š,Ï‰â‚•,Ï‰â‚š,Wâ‚€â‚•,Wâ‚€â‚š,sâ‚•,sâ‚š,Î³,Ïâ‚€,tempres,sep=","),append=T);	

	// time-series.csv
	tsfn = "~/gsccs-data/time-series.csv";
	writeFile(tsfn,paste("t","Nh","Np","zh","zp","vh","vp","pr_unhosted","pr_unparasitized",
		"pprh_m","pprh_v","pntcorr","muh","mup","pdv","pdm",sep=","),append=F);

	defineGlobal("j", 1);	
	defineGlobal("maxZ", 0);	
	defineGlobal("minZ", 0);			
	defineConstant("Î¨â‚•", Î¹);	// host mate choice distance
	defineConstant("Î¨â‚š", Î¹);  // parasite mate choice distance
	
	// host spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=3*Ï‰â‚•);
	i1.setInteractionFunction("n", 1.0, Ï‰â‚•);
	
	// parasite spatial competition
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=3*Ï‰â‚š);
	i2.setInteractionFunction("n", 1.0, Ï‰â‚š); // gaussian because it has nice edge effect properties?
	
	// host mate choice
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=Î¨â‚•);
	i3.setInteractionFunction("l", 1.0); // linear for speed
	
	// parasite mate choice
	initializeInteractionType(4, "xy", reciprocal=T, maxDistance=Î¨â‚š);
	i4.setInteractionFunction("l", 1.0);
	
	// parasitism
	initializeInteractionType(5, "xy", reciprocal=T, maxDistance=Î¹);
	i5.setInteractionFunction("l", 1.0);
}

species host initialize() {
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸ¦Œ");
	//initializeTreeSeq();
	
	// host genomics
	initializeMutationRate(Âµâ‚•);
	initializeMutationType("m1", 0.5, "n", 0.0, Îºâ‚•);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e8-1);
	initializeRecombinationRate(1e-8);

}

species para initialize() {
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸª±");
	//initializeTreeSeq();
	
	// parasite genomics
	initializeMutationRate(Âµâ‚š);
	initializeMutationType("m2", 0.5, "n", 0.0, Îºâ‚š);
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g2, 0, 1e8-1);
	initializeRecombinationRate(1e-8);
}

// make causal mutions neutral :B
species host fitness(m1) { return 1.0; }
species para fitness(m2) { return 1.0; }

// host mating
species host reproduction(p0) {
	mate = i3.drawByStrength(individual, 1); // find a single partner to mate with
	if(mate.size()) {
		wâ‚• = rpois(1, individual.tagF);
		if(wâ‚•>0){
			offspring = sapply(seqLen(wâ‚•), "subpop.addCrossed(individual, mate);");
			positions = rep(individual.spatialPosition,wâ‚•) + cbind(rnorm(wâ‚•, 0, Ïƒâ‚•), rnorm(wâ‚•, 0, Ïƒâ‚•));
			positions = p1.pointReflected(positions);
			offspring.setSpatialPosition(positions);
		}
	}
	return;
}

// parasite mating
species para reproduction(p1) {
	mate = i4.drawByStrength(individual, 1);
	if(mate.size()) {
		wâ‚š = rpois(1, individual.tagF);
		if(wâ‚š>0){
			offspring = sapply(seqLen(wâ‚š), "subpop.addCrossed(individual, mate);");
			positions = rep(individual.spatialPosition,wâ‚š) + cbind(rnorm(wâ‚š, 0, Ïƒâ‚š), rnorm(wâ‚š, 0, Ïƒâ‚š));
			positions = p1.pointReflected(positions);
			offspring.setSpatialPosition(positions);
		}
	}
	return;
}

ticks all 1 early() {
	mmn = paste0("~/gsccs-data/minmax.csv"); // for plotting later
	writeFile(mmn,paste("min","max",sep=","),append=F);
	Nâ‚€ = asInteger(Ïâ‚€ * 100 * 100); // Initial Population Size (Ïâ‚€ ind's per unit area)
//	host.readFromPopulationFile("~/gsccs-data/hinit.trees",
//		subpopMap=Dictionary("p0", 0)); // consider if dfe looks different for msprime vs slim
//	para.readFromPopulationFile("~/gsccs-data/pinit.trees",
//		subpopMap=Dictionary("p1", 0)); // and also if later dynamics change depending
	host.addSubpop("p0", Nâ‚€);
	para.addSubpop("p1", Nâ‚€);
	p0.setSpatialBounds(c(0, 0, 100, 100));
	p1.setSpatialBounds(c(0, 0, 100, 100));
	p0.individuals.setSpatialPosition(p0.pointUniform(Nâ‚€));
	p1.individuals.setSpatialPosition(p1.pointUniform(Nâ‚€));
	
//	community.rescheduleScriptBlock(s1, start=2, end=ntlbrnn);
//	community.rescheduleScriptBlock(s2, start=ntlbrnn+1, end=ixnbrnn);
//	community.rescheduleScriptBlock(s3, start=ixnbrnn, end=ixnbrnn);
}

ticks all 2:9999 first(){
	i1.evaluate(p0);
	i2.evaluate(p1);
	i3.evaluate(p0);
	i4.evaluate(p1);
	i5.evaluate(p0);
	i5.evaluate(p1);
	
	// caculating the phenotype as sum of loci with mutation
	zâ‚• = p0.individuals.sumOfMutationsOfType(m1);
	zâ‚š = p1.individuals.sumOfMutationsOfType(m2);
	
	// save trait values (for coloring later)
	p0.individuals.z = zâ‚•;
	p1.individuals.z = zâ‚š;
	
	// containers for dist's parasites move to hosts
	pd = rep(0.0,p1.individualCount);
	
	// compute fx of intraspp comp on host fecun
	Nâ‚• = i1.localPopulationDensity(p0.individuals); // be sure to set the intxn kernel to a gaussian
	p0.individuals.tagF = Wâ‚€â‚•*exp(-câ‚•*Nâ‚•);

	// compute fx of intraspp comp on para fecun
	Nâ‚š = i2.localPopulationDensity(p1.individuals);
	p1.individuals.tagF = Wâ‚€â‚š*exp(-câ‚š*Nâ‚š);
	
	// forces non-overlapping generations	
	p0.individuals.fitnessScaling = 0;
	p1.individuals.fitnessScaling = 0;

	// any unhosted parasite gets int tag 0
	p0.individuals.tag = 0;	
	
	// any unparasitized hosts gets int tag 0
	p1.individuals.tag = 0;		
		
	// logging position, trait value, fitness, parasite movement and species id for each individual
	if(community.tick%tempres==2){ // mod->2 because 2 is the "first" cycle
		
		catn(j);
		
		// computing max and mins
		maxZ = max(c(zâ‚•,zâ‚š));
		minZ = min(c(zâ‚•,zâ‚š));
		mmn = paste0("~/gsccs-data/minmax.csv");
		writeFile(mmn,paste(minZ,maxZ,sep=","),append=T);
		
		// summary stats
		zh = mean(p0.individuals.z);
		zp = mean(p1.individuals.z);
		vh = var(p0.individuals.z);
		vp = var(p1.individuals.z);
		pr_unhosted = sum(p0.individuals.tag)/p0.individualCount;
		pr_unparasitized = sum(p1.individuals.tag>0)/p1.individualCount;
		pprh_m = mean(p1.individuals.tag);
		pprh_v = var(p1.individuals.tag);
		muh = mean(p0.individuals.countOfMutationsOfType(m1));
		mup = mean(p1.individuals.countOfMutationsOfType(m2));
		tsfn = "~/gsccs-data/time-series.csv";
		writeFile(tsfn,paste(community.tick,p0.individualCount,p1.individualCount,zh,zp,vh,vp,
			pr_unhosted,pr_unparasitized,pprh_m,pprh_v,0,muh,mup,0,0,sep=","),append=T);
	
		// individual location and trait data
		fn = paste0("~/gsccs-data/ind-data/indData",format("%04i",j),".csv");
		j = j+1;
		writeFile(fn,paste("x","y","z","spp",sep=","),append=F); // pd = distance parasite moves to host
		for(h in p0.individuals){
			writeFile(fn,paste(h.x,h.y,h.z,1,sep=","),append=T); // pd = 0 for hosts
		}
		for(p in p1.individuals){
			writeFile(fn,paste(p.x,p.y,p.z,2,sep=","),append=T);
		}
	}

}

ticks all 10000:20000 first(){
	i1.evaluate(p0);
	i2.evaluate(p1);
	i3.evaluate(p0);
	i4.evaluate(p1);
	i5.evaluate(p0);
	i5.evaluate(p1);
	
	// caculating the phenotype as sum of loci with mutation
	zâ‚• = p0.individuals.sumOfMutationsOfType(m1);
	zâ‚š = p1.individuals.sumOfMutationsOfType(m2);
	
	// save trait values (for coloring later)
	p0.individuals.z = zâ‚•;
	p1.individuals.z = zâ‚š;
	
	// containers for dist's parasites move to hosts
	pd = rep(0.0,p1.individualCount);
	
	// compute fx of intraspp comp on host fecun
	Nâ‚• = i1.localPopulationDensity(p0.individuals);
	p0.individuals.tagF = Wâ‚€â‚•*exp(-câ‚•*Nâ‚•);

	// compute fx of intraspp comp on para fecun
	Nâ‚š = i2.localPopulationDensity(p1.individuals);
	p1.individuals.tagF = Wâ‚€â‚š*exp(-câ‚š*Nâ‚š);
	
	// any unhosted parasite gets int tag 0
	p0.individuals.tag = 0;	
	
	// any unparasitized hosts gets int tag 0
	p1.individuals.tag = 0;
	
	// parasite traits included in computing trait correlation
	ptc = c();

	// host traits included in computing trait correlation
	htc = c();
			
	// compute fx of intraspp comp on para fecun
	// and incorporate fx of interspp intxns on host/para fecun
	for(p in p1.individuals){		
		
		// save parasite location for later	
		pp = c(p.x,p.y);
		
		h = i5.nearestInteractingNeighbors(p,1,p0); // consider drawByStrength
		if(length(h)>0){
		
			// move parasite to that host
			p.setSpatialPosition(c(h.x,h.y));
		
			// hosted parasites get int tag 1
			p.tag = 1;
		
			// save distance parasite moved to host
			pd[p.index] = sqrt(sum((c(p.x,p.y)-pp)^2));		
		
			// trait-matching-model
			Î± = exp(-Î³*abs(h.z-p.z));
		
			// deterministic fitness outcome is faster and easier to analyze
			p.tagF = (exp(sâ‚š)*Î± + (1-Î±)) * p.tagF;
			h.tagF = (exp(-sâ‚•)*Î± + (1-Î±)) * h.tagF;
			
			// increment host int tag to reflect num parasites
			h.tag = h.tag + 1;
			
			// append trait pair for corr computation
			ptc = c(ptc,p.z);
			htc = c(htc,h.z);			
		}

		// note: each parasite infects at most one host, but each host can be infected by multiple parasites
		//			hence, if a host is infected by three parasites it will incur the fitness cost of 3*sâ‚•
	}
	
	// forces non-overlapping generations	
	p0.individuals.fitnessScaling = 0;
	p1.individuals.fitnessScaling = 0;
	
	maxZ = max(c(zâ‚•,zâ‚š));
	minZ = min(c(zâ‚•,zâ‚š));
	mmn = paste0("~/gsccs-data/minmax.csv");
	writeFile(mmn,paste(minZ,maxZ,sep=","),append=T);
	
	// logging position, trait value, fitness, parasite movement and species id for each individual
	if(community.tick%tempres==2){
	
		catn(j);
		
		// summary stats
		zh = mean(p0.individuals.z);
		zp = mean(p1.individuals.z);
		vh = var(p0.individuals.z);
		vp = var(p1.individuals.z);
		pr_unhosted = sum(p0.individuals.tag)/p0.individualCount;
		pr_unparasitized = sum(p1.individuals.tag>0)/p1.individualCount;
		pprh_m = mean(p1.individuals.tag);
		pprh_v = var(p1.individuals.tag);
		traitcorr = corr(ptc,htc);
		muh = mean(p0.individuals.countOfMutationsOfType(m1));
		mup = mean(p1.individuals.countOfMutationsOfType(m2));
		pdm = mean(pd);
		pdv = var(pd);
		tsfn = "~/gsccs-data/time-series.csv";
		writeFile(tsfn,paste(community.tick,p0.individualCount,p1.individualCount,zh,zp,vh,vp,
			pr_unhosted,pr_unparasitized,pprh_m,pprh_v,traitcorr,muh,mup,pdv,pdm,sep=","),append=T);
	
		// individual location and trait data
		fn = paste0("~/gsccs-data/ind-data/indData",format("%04i",j),".csv");
		j = j+1;
		writeFile(fn,paste("x","y","z","spp",sep=","),append=F);
		for(h in p0.individuals){
			writeFile(fn,paste(h.x,h.y,h.z,1,sep=","),append=T);
		}
		for(p in p1.individuals){
			writeFile(fn,paste(p.x,p.y,p.z,2,sep=","),append=T);
		}
	}

}

//ticks all 3: late(){
//	for(subpop in c(p0,p1)){
//		val = cbind(((0.5+subpop.individuals.z)%0.02)/0.02,
//		rep(0.75,subpop.individualCount), 
//		rep(0.75,subpop.individualCount));
//		subpop.individuals.color = rgb2color(hsv2rgb(val));
//	}
//}

ticks all 20000 late() {
	//host.treeSeqOutput("~/gsccs-data/host.trees", metadata=params);
	//para.treeSeqOutput("~/gsccs-data/para.trees", metadata=params);
	community.simulationFinished();
	catn("Done.");
}