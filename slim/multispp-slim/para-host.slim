species host initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸ¦Œ");
	initializeTreeSeq();
	
	// model parameters
	defaults = Dictionary(
		"Âµâ‚•", 0.5,  		// host mutation effect size
		"Âµâ‚š", 0.5,  		// parasite mutation effect size
		"Ïƒâ‚•", 2.0,  		// host dispersal distance	
		"Ïƒâ‚š", 2.0,  		// parasite dispersal distance
		"Î¹", 1.0,  			// spatial interspp interaction distance
		"câ‚•", 0.02, 		// strength of host competition
		"câ‚š", 0.02, 		// strength of para competition	
		"Î¾", 2.0,			// (spatial) niche breadth
		"Wâ‚€â‚•", 1.2,			// host base fitness
		"Wâ‚€â‚š", 1.2,			// para base fitness
		"sâ‚•", 0.98, 		// multiplicative cost on host fitness for each infection
		"sâ‚š", 1.01, 		// multiplicative benefit on parasite fitness for successful infection
		"Ï€â‚˜", 1.0,			// maximum probability of infection
		"Î³", 0.1				// sensitivity of inf pr to trait differences
		);
	for (k in defaults.allKeys) {
		if (!exists(k)) {
			defineConstant(k, defaults.getValue(k));
		} else {
			defaults.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
	}
	defineGlobal("params", defaults);
	defineConstant("hSM", Ïƒâ‚•);  			// host mate choice distance
	defineConstant("pSM", Ïƒâ‚š);  			// parasite mate choice distance
	
	
	// host genomics
	initializeMutationRate(1e-7);
	initializeMutationType("m1", 0.5, "n", 0.0, Âµâ‚•);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e8-1);
	initializeRecombinationRate(1e-8);
	
	// host spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=Î¾);
	
	// host mate choice
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=hSM);
	
	// parasitism
	initializeInteractionType(5, "xy", reciprocal=T, maxDistance=Î¹);
}

species para initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸª±");
	initializeTreeSeq();
	
	// parasite genomics
	initializeMutationRate(1e-7);
	initializeMutationType("m2", 0.5, "n", 0.0, Âµâ‚š);
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g2, 0, 1e8-1);
	initializeRecombinationRate(1e-8);
	
	// parasite spatial competition
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=Î¾);
	
	// parasite mate choice
	initializeInteractionType(4, "xy", reciprocal=T, maxDistance=pSM);
}

// make causal mutions neutral :B
species host fitness(m1) { return 1.0; }
species para fitness(m2) { return 1.0; }

// host mating
species host reproduction(p1) {
	mate = i3.drawByStrength(individual, 1); // find a single partner to mate with
	if(mate.size()) {
		nOff = rpois(1, individual.tagF);
		for(i in seqLen(nOff)) {
			subpop.addCrossed(individual, mate);
		}
	}
	return;
}

// parasite mating
species para reproduction(p2) {
	mate = i4.drawByStrength(individual, 1);
	if(mate.size()) {
		nOff = rpois(1, individual.tagF);
		for(i in seqLen(nOff)) {
			subpop.addCrossed(individual, mate);
		}
	}
	return;
}

species host modifyChild() {
	// Absorbing boundary conditions
	pos = parent1.spatialPosition + rnorm(2, 0, Ïƒâ‚•);
	if (!p1.pointInBounds(pos))
		return F;
	child.setSpatialPosition(pos);
	return T;
}

species para modifyChild() {
	// Absorbing boundary conditions
	pos = parent1.spatialPosition + rnorm(2, 0, Ïƒâ‚š);
	if (!p1.pointInBounds(pos))
		return F;
	child.setSpatialPosition(pos);
	return T;
}

ticks all 1 early() {
	IPS = asInteger(1 * 100 * 100); // Initial Population Size (one ind per unit area)
	host.addSubpop("p1", IPS);
	para.addSubpop("p2", IPS);
	p1.setSpatialBounds(c(0, 0, 100, 100));
	p2.setSpatialBounds(c(0, 0, 100, 100));
	p1.individuals.setSpatialPosition(p1.pointUniform(IPS));
	p2.individuals.setSpatialPosition(p1.pointUniform(IPS));
}

ticks all late(){
	i1.evaluate(p1);
	i2.evaluate(p2);
	i3.evaluate(p1);
	i4.evaluate(p2);
	i5.evaluate(p1);
	
	// caculating the phenotype as sum of loci with mutation
	zâ‚• = p1.individuals.sumOfMutationsOfType(m1);
	zâ‚š = p2.individuals.sumOfMutationsOfType(m2);
	
	// save trait values
	p1.individuals.z = zâ‚•;
	p2.individuals.z = zâ‚š;
	
	// identify genotypes by brightness
	for(ind in p1.individuals){
		val = (ind.z%100)/100;
		ind.color = rgb2color(hsv2rgb(c(val, 0.75, 0.75)));
	}
	for(ind in p2.individuals){
		val = (ind.z%100)/100;
		ind.color = rgb2color(hsv2rgb(c(val, 0.75, 0.75)));
	}
	
	// compute fx of intraspp comp on host fecun
	for(h in p1.individuals){
		h_loc = c(h.x,h.y);
		h_nbs = i1.interactingNeighborCount(h);
		h.tagF = Wâ‚€â‚•*exp(-câ‚•*h_nbs);
	}
	
	// compute fx of intraspp comp on para fecun
	// and incorporate fx of interspp intxns on host/para fecun
	for(p in p2.individuals){
		p_loc = c(p.x,p.y);
		p_nbs = i2.interactingNeighborCount(p);
		Wâ‚š = Wâ‚€â‚š*exp(-câ‚š*p_nbs);
		
		// if there's any hosts out there
		if( p1.individualCount > 0 ){
			// draw hosts within radius Î¹ of focal parasite
			h_nbrs= i5.nearestNeighborsOfPoint(p1, p_loc, count=p1.individualCount);
		} else h_nbrs = c();
		
		// if there's hosts nearby
		if(length(h_nbrs) > 0){
			
			// choose one living host at random for parasite to interact with
			hnb = h_nbrs[rdunif(1, 0, length(h_nbrs)-1)];
			
			// trait-matching-model
			Ï€ = Ï€â‚˜*exp(-Î³*(zâ‚•[hnb.index]-zâ‚š[p.index])^2/2);
			
			// deterministic fitness outcome is faster and easier to analyze
			Wâ‚š = (sâ‚š*Ï€ + (1-Ï€)) * Wâ‚š;
			hnb.tagF = (sâ‚•*Ï€ + (1-Ï€)) * hnb.tagF;
		
		}
		// note: each parasite infects at most one host, but each host can be infected by multiple parasites
		//			hence, if a host is infected by three parasites it will incur the fitness cost of sâ‚•^3
		p.tagF = Wâ‚š;
	}
	
	// forces non-overlapping generations	
	p2.individuals.fitnessScaling = 0;
	p1.individuals.fitnessScaling = 0;
}

ticks all 2000 late() {
	host.treeSeqOutput("host.trees", metadata=params);
	para.treeSeqOutput("para.trees", metadata=params);
	catn("Done.");
	host.simulationFinished();
	para.simulationFinished();
}