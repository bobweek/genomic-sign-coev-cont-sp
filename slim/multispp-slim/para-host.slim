species all initialize(){
	initializeSLiMModelType("nonWF");
	// model parameters
	defaults = Dictionary(	
		"Âµâ‚•",  1e-8,  		// host mutation rate
		"Âµâ‚š",  1e-8,  		// parasite mutation rate
		"Îºâ‚•",  0.01,  		// host mutation effect size (greek letter 'mu' for 'mutation')
		"Îºâ‚š",  0.01,  		// parasite mutation effect size		
		"Ïƒâ‚•",  2.5,  		// host dispersal distance	('sigma' is trad notation for disp dist)
		"Ïƒâ‚š",  2.5,  		// parasite dispersal distance
		"Î¹",   2.5,			// spatial interspp interaction distance ('iota' for 'interaction')
		"câ‚•",  0.002, 		// strength of host competition
		"câ‚š",  0.002, 		// strength of para competition
		"Ï‰â‚•",  3.0,			// (spatial) host niche breadth ('omega' looks like w for 'width', trad quant gen notation)
		"Ï‰â‚š",  3.0,			// (spatial) parasite niche breadth
		"Wâ‚€â‚•", 1.1,			// host base fitness ('W' trad notation for expected liftme repr output)
		"Wâ‚€â‚š", 1.05,		// para base fitness
		"sâ‚•",  0.01, 		// cost on host fitness for each infection ('s' as in selection)
		"sâ‚š",  0.01, 		// benefit on parasite fitness for successful infection
		"Î³",   1.0,			// sensitivity of inf pr to trait differences ('gamma' trad nuimser notation for this par)
		"Ïâ‚€",  0.2			// initial population density ('rho' is trad for densities)
		);
	for (k in defaults.allKeys) {
		if (!exists(k)) {
			defineConstant(k, defaults.getValue(k));
		} else {
			defaults.setValue(k, executeLambda(paste(c(k, ";"), sep='')));
		}
	}
	defineGlobal("params", defaults);
	defineGlobal("j", 0);	
	defineConstant("Î¨â‚•", Ïƒâ‚•);	// host mate choice distance
	defineConstant("Î¨â‚š", Ïƒâ‚š);  // parasite mate choice distance	
	
	// host spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=Ï‰â‚•);
	//i1.setInteractionFunction("n", 1.0, Ï‰â‚•/3);
	
	// parasite spatial competition
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=Ï‰â‚š);
	
	// host mate choice
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=Î¨â‚•);
	
	// parasite mate choice
	initializeInteractionType(4, "xy", reciprocal=T, maxDistance=Î¨â‚š);
	
	// parasitism
	initializeInteractionType(5, "xy", reciprocal=F, maxDistance=Î¹);

}

species host initialize() {
	initializeSLiMOptions(dimensionality="xy",periodicity="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸ¦Œ");
	//initializeTreeSeq();
	
	// host genomics
	initializeMutationRate(Âµâ‚•);
	initializeMutationType("m1", 0.5, "n", 0.0, Îºâ‚•);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e8-1);
	initializeRecombinationRate(1e-8);

}

species para initialize() {
	initializeSLiMOptions(dimensionality="xy",periodicity="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸª±");
	//initializeTreeSeq();
	
	// parasite genomics
	initializeMutationRate(Âµâ‚š);
	initializeMutationType("m2", 0.5, "n", 0.0, Îºâ‚š);
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g2, 0, 1e8-1);
	initializeRecombinationRate(1e-8);
}

// make causal mutions neutral :B
species host fitness(m1) { return 1.0; }
species para fitness(m2) { return 1.0; }

// host mating
species host reproduction(p0) {
	mate = i3.drawByStrength(individual, 1); // find a single partner to mate with
	if(mate.size()) {
		ð“¦â‚•= rpois(1, individual.tagF);
		for(i in seqLen(ð“¦â‚•)) {
			pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚•);
			bb = subpop.addCrossed(individual, mate);
			bb.setSpatialPosition(p0.pointPeriodic(pos));
		}
	}
	return;
}
//species host modifyChild() {
//	// Absorbing boundary conditions
//	pos = parent1.spatialPosition + rnorm(2, 0, Ïƒâ‚•);
//	if (!p0.pointInBounds(pos))
//		return F;
//	child.setSpatialPosition(pos);
//	return T;
//}


// parasite mating
species para reproduction(p1) {
	mate = i4.drawByStrength(individual, 1);
	if(mate.size()) {
		ð“¦â‚š = rpois(1, individual.tagF);
		for(i in seqLen(ð“¦â‚š)) {
			pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚š);
			bb = subpop.addCrossed(individual, mate);
			bb.setSpatialPosition(p1.pointPeriodic(pos));
		}
	}
	return;
}
//species para modifyChild() {
//	// Absorbing boundary conditions
//	pos = parent1.spatialPosition + rnorm(2, 0, Ïƒâ‚š);
//	if (!p0.pointInBounds(pos))
//		return F;
//	child.setSpatialPosition(pos);
//	return T;
//}

ticks all 1 early() {
	Nâ‚€ = asInteger(Ïâ‚€ * 100 * 100); // Initial Population Size (Ïâ‚€ ind's per unit area)
	host.addSubpop("p0", Nâ‚€);
	para.addSubpop("p1", Nâ‚€);
	p0.setSpatialBounds(c(0, 0, 100, 100));
	p1.setSpatialBounds(c(0, 0, 100, 100));
	p0.individuals.setSpatialPosition(p0.pointUniform(Nâ‚€));
	p1.individuals.setSpatialPosition(p1.pointUniform(Nâ‚€));
	//host.readFromPopulationFile("~/gsccs-data/hinit.trees");
	//para.readFromPopulationFile("~/gsccs-data/pinit.trees");
}

ticks all late(){
	i1.evaluate(p0);
	i2.evaluate(p1);
	i3.evaluate(p0);
	i4.evaluate(p1);
	i5.evaluate(p0);
	
	// caculating the phenotype as sum of loci with mutation
	zâ‚• = p0.individuals.sumOfMutationsOfType(m1);
	zâ‚š = p1.individuals.sumOfMutationsOfType(m2);
	
	// save trait values
	p0.individuals.z = zâ‚•;
	p1.individuals.z = zâ‚š;
	
	// containers for dist's parasites move to hosts
	pd = rep(0.0,p1.individualCount);
	
	// identify phenotypes by hue
	for(ind in p0.individuals){
		val = (ind.z%10)/10;
		ind.color = rgb2color(hsv2rgb(c(val, 0.75, 0.75)));
	}
	for(ind in p1.individuals){
		val = (ind.z%10)/10;
		ind.color = rgb2color(hsv2rgb(c(val, 0.75, 0.75)));
	}
	
	// compute fx of intraspp comp on host fecun
	for(h in p0.individuals){
		Nâ‚• = i1.interactingNeighborCount(h);
		p0.individuals.tagF = Wâ‚€â‚•*exp(-câ‚•*Nâ‚•);
	}
//	Nâ‚• = i1.localPopulationDensity(p0.individuals); // be sure to set the intxn kernel to a gaussian
//	catn(Nâ‚•);
	
	
	// compute fx of intraspp comp on para fecun
	// and incorporate fx of interspp intxns on host/para fecun
	for(p in p1.individuals){
		Nâ‚š = i2.interactingNeighborCount(p);
		Wâ‚š = Wâ‚€â‚š*exp(-câ‚š*Nâ‚š);
		
		// if there's any hosts out there
		if( p0.individualCount > 0 ){
			// draw hosts within radius Î¹ of focal parasite
			h_nbrs = i5.nearestNeighborsOfPoint(c(p.x,p.y), p0, count=p0.individualCount);
			// not using p.spatialPosition because im scared it'll create dependency on z
		} else h_nbrs = c();
		
		// if there's hosts nearby
		if(length(h_nbrs) > 0){
			
			// choose one living host at random for parasite to interact with
			h = h_nbrs[rdunif(1, 0, length(h_nbrs)-1)]; // replace with gauss weighting (there may be a fct for this)
			
			pp = c(p.x,p.y);
			
			// move parasite to that host
			p.setSpatialPosition(c(h.x,h.y));
			// not using h.spatialPosition because im scared it'll copy z
			
			pd[p.index] = sqrt(sum((c(p.x,p.y)-pp)^2));
			
			// trait-matching-model
			Î± = exp(-Î³*abs(zâ‚•[h.index]-zâ‚š[p.index])/2);
			
			// deterministic fitness outcome is faster and easier to analyze
			Wâ‚š = (exp(sâ‚š)*Î± + (1-Î±)) * Wâ‚š;
			h.tagF = (exp(-sâ‚•)*Î± + (1-Î±)) * h.tagF;
		
		}
		// note: each parasite infects at most one host, but each host can be infected by multiple parasites
		//			hence, if a host is infected by three parasites it will incur the fitness cost of sâ‚•^3
		p.tagF = Wâ‚š;
	}
	
	// forces non-overlapping generations	
	p1.individuals.fitnessScaling = 0;
	p0.individuals.fitnessScaling = 0;
	
	// logging position, trait value, fitness and species id for each individual
	if(community.tick>3999){
		fn = paste0("~/gsccs-data/ind-data/indData",format("%04i",j),".csv");
		j = j+1;
		writeFile(fn,paste("x","y","z","W","pd","spp",sep=","),append=F); // pd = distance parasite moves to host
		for(h in p0.individuals){
			writeFile(fn,paste(h.x,h.y,zâ‚•[h.index],h.tagF,0,1,sep=","),append=T); // pd = 0 for hosts
		}
		for(p in p1.individuals){
			writeFile(fn,paste(p.x,p.y,zâ‚š[p.index],p.tagF,pd[p.index],2,sep=","),append=T);
		}
	}

}

ticks all 5000 late() {
	//host.treeSeqOutput("~/gsccs-data/host.trees", metadata=params);
	//para.treeSeqOutput("~/gsccs-data/para.trees", metadata=params);
	community.simulationFinished();
	catn("Done.");
}