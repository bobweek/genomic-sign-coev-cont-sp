// this version does not produce time-series

species all initialize(){
	initializeSLiMModelType("nonWF");
	// model parameters (parfname provided as an argument)
//	if(!exists("parfname")) c
//		defineConstant("parfname","~/gits/genomic-sign-coev-cont-sp/peqg22/slim-pars.csv");
	prs = readCSV(parfname);
	defineGlobal("params", prs);
	for (k in prs.allKeys) defineConstant(k, prs.getValue(k));	
	
	// host spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=3*Ï‰â‚•);
	i1.setInteractionFunction("n", 1.0, Ï‰â‚•);
	
	// parasite spatial competition
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=3*Ï‰â‚š);
	i2.setInteractionFunction("n", 1.0, Ï‰â‚š); // gaussian because it has nice edge effect properties?
	
	// host mate choice
	initializeInteractionType(3, "xy", reciprocal=T, maxDistance=4*Ï‰â‚•);
	i3.setInteractionFunction("l", 1.0); // linear for speed
	
	// parasite mate choice
	initializeInteractionType(4, "xy", reciprocal=T, maxDistance=8*Ï‰â‚š);
	i4.setInteractionFunction("l", 1.0);
	
	// parasitism
	initializeInteractionType(5, "xy", reciprocal=T, maxDistance=Î¹);
	i5.setInteractionFunction("l", 1.0);
}

species host initialize() {
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸ¦Œ");
	initializeTreeSeq();
	
	// host genomics
	initializeMutationRate(Âµâ‚•);
	initializeMutationType("m1", 0.5, "n", 0.0, Îºâ‚•);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e8-1);
	initializeRecombinationRate(1e-8);

}

species para initialize() {
	initializeSLiMOptions(dimensionality="xy");
	initializeSpecies(tickModulo=1, tickPhase=1, avatar="ðŸª±");
	initializeTreeSeq();
	
	// parasite genomics
	initializeMutationRate(Âµâ‚š);
	initializeMutationType("m2", 0.5, "n", 0.0, Îºâ‚š);
	initializeGenomicElementType("g2", m2, 1.0);
	initializeGenomicElement(g2, 0, 1e8-1);
	initializeRecombinationRate(1e-8);
}

// make causal mutions neutral :B
species host fitness(m1) { return 1.0; }
species para fitness(m2) { return 1.0; }

// host mating
species host reproduction(p0) {
	mate = i3.drawByStrength(individual, 1); // find a single partner to mate with
	if(mate.size()) {
		offspring = subpop.addCrossed(individual, mate);
		pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚•);
		pos = p0.pointReflected(pos);
		offspring.setSpatialPosition(pos);
	} else{
		offspring = subpop.addCrossed(individual, individual);
		pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚•);
		pos = p0.pointReflected(pos);
		offspring.setSpatialPosition(pos);	
	}
	return;
}

// parasite mating
species para reproduction(p1) {
	mate = i4.drawByStrength(individual, 1);
	if(mate.size()) {
		offspring = subpop.addCrossed(individual, mate);
		pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚š);
		pos = p1.pointReflected(pos);
		offspring.setSpatialPosition(pos);
	} else{
		offspring = subpop.addCrossed(individual, individual);
		pos = individual.spatialPosition + rnorm(2, 0, Ïƒâ‚š);
		pos = p1.pointReflected(pos);
		offspring.setSpatialPosition(pos);	
	}
	return;
}

ticks all 1 early() {
	host.readFromPopulationFile("~/gsccs-data/hinit.trees",
		subpopMap=Dictionary("p0", 0)); // consider if dfe looks different for msprime vs slim
	para.readFromPopulationFile("~/gsccs-data/pinit.trees",
		subpopMap=Dictionary("p1", 0)); // and also if later dynamics change depending
	p0.setSpatialBounds(c(0, 0, 100, 100));
	p1.setSpatialBounds(c(0, 0, 100, 100));
	p0.individuals.setSpatialPosition(p0.pointUniform(p0.individualCount));
	p1.individuals.setSpatialPosition(p1.pointUniform(p1.individualCount));
	
//	community.rescheduleScriptBlock(s1, start=2, end=ntlbrnn);
//	community.rescheduleScriptBlock(s2, start=ntlbrnn+1, end=ixnbrnn);
//	community.rescheduleScriptBlock(s3, start=ixnbrnn, end=ixnbrnn);
}

ticks all 2:50000 first(){
	i3.evaluate(p0);
	i4.evaluate(p1);
}

ticks all 2:50000 early(){
	i1.evaluate(p0);
	i2.evaluate(p1);
	i5.evaluate(p0);
	i5.evaluate(p1);
	
	// caculating the phenotype as sum of loci with mutation
	zâ‚• = p0.individuals.sumOfMutationsOfType(m1)+1;// + rnorm(p0.individualCount,0,Îµâ‚•);
	zâ‚š = p1.individuals.sumOfMutationsOfType(m2)-1;// + rnorm(p1.individualCount,0,Îµâ‚š);
	
	//
	// intraspp competition
	//	
	
	// compute fx of intraspp comp on host fecun
	Nâ‚• = i1.localPopulationDensity(p0.individuals);
	Wâ‚• = Wâ‚€â‚•*exp(-câ‚•*Nâ‚•);

	// compute fx of intraspp comp on para fecun
	Nâ‚š = i2.localPopulationDensity(p1.individuals);
	Wâ‚š = Wâ‚€â‚š*exp(-câ‚š*Nâ‚š);

	//
	// host-parasite interactions
	//

	// grab indices of hosts selected by parasites (set -1 if no host selected)
	hs = sapply(p1.individuals,"h = i5.nearestInteractingNeighbors(applyValue,1,p0); if (length(h)>0) h.index; else -1;");
	
	//	grab indices of host indices present in selected vector
	// note: if no parasites this returns an error
	// but since we dont care what happens without parasites
	// this terminates the simulation for us, so we keep it
	u = hs>-1;
	
	// grab host indices in selected vector
	// and indices of parasites that found a host
	hs = hs[u];
	ps = p1.individuals.index[u];
	
	// probability of infection (trait matching)
	Î± = exp(-Î³*(zâ‚•[hs]-zâ‚š[u])^2/2);
	
	// biotic component of selection	
	Bâ‚• = rep(1.0,p0.individualCount);
	Bâ‚š = rep(1.0,p1.individualCount);
	
	// deterministic fitness outcome (expectation of coin toss)
	Bâ‚•[hs] = (exp(-sâ‚•)*Î± + (1-Î±));
	Bâ‚š[u] = (exp(sâ‚š)*Î± + (1-Î±));
	Wâ‚• =  Bâ‚•*Wâ‚•;
	Wâ‚š =  Bâ‚š*Wâ‚š;
	
	// mortality probability
	p0.individuals.fitnessScaling = floor(2*Wâ‚•);
	p1.individuals.fitnessScaling = floor(2*Wâ‚š);
	
}

ticks all 50000 late() {
	host.treeSeqOutput("~/gsccs-data/host-slim.trees", metadata=params);
	para.treeSeqOutput("~/gsccs-data/para-slim.trees", metadata=params);
	community.simulationFinished();
	catn("Done.");
}